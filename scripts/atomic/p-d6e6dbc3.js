import{h as t,H as n,g as i,f as e}from"./p-dc3df5ce.js";import{c as s}from"./p-c9074946.js";import{b as o}from"./p-1580513b.js";import{e as r}from"./p-05de7ca3.js";import{M as a,i as c,a as h}from"./p-f77160c6.js";const d=()=>t(n,{class:"atomic-hidden"});function f(t){return new Promise(((n,i)=>{const e=o(c,(t=>n(t)));const d=s(t,h.join(", "));if(!d){i(new a(t.nodeName.toLowerCase()));return}r(d,e,t)}))}const l="data-atomic-rendered";const u="data-atomic-loaded";function p({forceUpdate:n}={}){return(f,p)=>{const{componentWillLoad:m,render:g,componentDidRender:b,componentDidLoad:C,disconnectedCallback:j}=f;let y=()=>{};if(p!=="bindings"){return console.error(`The InitializeBindings decorator should be used on a property called "bindings", and not "${p}"`,f)}f.componentWillLoad=function(){const t=i(this);t.setAttribute(l,"false");t.setAttribute(u,"false");const d=o(c,(t=>{this.bindings=t;const i=()=>e(this);this.bindings.i18n.on("languageChanged",i);y=()=>this.bindings.i18n.off("languageChanged",i);try{if(this.initialize){this.initialize();if(n){e(this)}}else{e(this)}}catch(t){this.error=t}}));const f=s(t,h.join(", "));if(!f){this.error=new a(t.nodeName.toLowerCase());return}r(f,d,t);return m&&m.call(this)};f.render=function(){if(this.error){return t("atomic-component-error",{element:i(this),error:this.error})}if(!this.bindings){return t(d,null)}i(this).setAttribute(l,"true");return g&&g.call(this)};f.disconnectedCallback=function(){const t=i(this);t.setAttribute(l,"false");t.setAttribute(u,"false");y();j&&j.call(this)};f.componentDidRender=function(){const t=i(this);if(t.getAttribute(l)==="false"){return}b&&b.call(this);if(t.getAttribute(u)==="false"){t.setAttribute(u,"true");C&&C.call(this)}};f.componentDidLoad=function(){}}}function m(t,n){return(e,s)=>{const{disconnectedCallback:o,initialize:r}=e;e.initialize=function(){r&&r.call(this);if(!r){return console.error(`ControllerState: The "initialize" method has to be defined and instantiate a controller for the property ${t}`,e)}if(!this[t]){return}if(n?.onUpdateCallbackMethod&&!this[n.onUpdateCallbackMethod]){return console.error(`ControllerState: The onUpdateCallbackMethod property "${n.onUpdateCallbackMethod}" is not defined`,e)}this.unsubscribeController=this[t].subscribe((()=>{this[s]=this[t].state;n?.onUpdateCallbackMethod&&this[n.onUpdateCallbackMethod]()}))};e.disconnectedCallback=function(){!i(this).isConnected&&this.unsubscribeController?.();o&&o.call(this)}}}export{m as B,d as H,p as I,f as i};
//# sourceMappingURL=p-d6e6dbc3.js.map