{"version":3,"names":["intersection","setA","setB","result","Set","elem","has","add","makeMatchConditions","mustMatch","mustNotMatch","conditions","field","mustNotMatchValues","mustMatchValues","commonValues","size","console","error","push","ProductTemplatesHelpers","fieldMustMatch","fieldMustNotMatch","getTemplateNodeType","node","isResultSectionNode","isVisualNode","isElementNode","tagName","toLowerCase","tableElementTagName","groupNodesByType","nodes","aggregate","Array","from","ProductTemplateCommon","constructor","host","setError","validParents","allowEmpty","this","matchConditions","validateTemplate","hasValidParent","map","p","toUpperCase","includes","parentElement","nodeName","Error","join","attributes","getNamedItem","value","gridCellLinkTarget","template","querySelector","innerHTML","trim","content","warn","section","sectionNodes","other","otherNodes","childNodes","length","getTemplate","concat","getTemplateElement","linkContent","getLinkTemplateElement","priority","renderIfError","h","element","getDefaultLinkTemplateElement","linkTemplate","document","createElement","makeDefinedConditions","ifDefined","ifNotDefined","fieldNames","split","fieldsMustBeDefined","fieldsMustNotBeDefined"],"sources":["src/utils/set.ts","src/components/common/product-template/product-template-common.ts","src/components/common/product-template/stencil-product-template-common.tsx"],"sourcesContent":["// TODO: Replace by Set.prototype.intersection in July 2025\nexport function intersection<T>(setA: Set<T>, setB: Set<T>): Set<T> {\n  const result = new Set<T>();\n  for (const elem of setA) {\n    if (setB.has(elem)) {\n      result.add(elem);\n    }\n  }\n  return result;\n}\n","import {\n  ProductTemplateCondition,\n  ProductTemplatesHelpers,\n} from '@coveo/headless/commerce';\nimport {intersection} from '../../../utils/set';\nimport {isElementNode, isVisualNode} from '../../../utils/utils';\nimport {tableElementTagName} from '../../search/atomic-table-result/table-element-utils';\nimport {isResultSectionNode} from '../layout/sections';\n\ntype TemplateNodeType =\n  | 'section'\n  | 'metadata'\n  | 'table-column-definition'\n  | 'other';\n\nexport function getTemplateNodeType(node: Node): TemplateNodeType {\n  if (isResultSectionNode(node)) {\n    return 'section';\n  }\n  if (!isVisualNode(node)) {\n    return 'metadata';\n  }\n  if (\n    isElementNode(node) &&\n    node.tagName.toLowerCase() === tableElementTagName\n  ) {\n    return 'table-column-definition';\n  }\n  return 'other';\n}\n\nexport function makeMatchConditions(\n  mustMatch: Record<string, string[]>,\n  mustNotMatch: Record<string, string[]>\n): ProductTemplateCondition[] {\n  const conditions: ProductTemplateCondition[] = [];\n  for (const field in mustMatch) {\n    if (mustNotMatch[field]) {\n      const mustNotMatchValues = new Set(mustNotMatch[field]);\n      const mustMatchValues = new Set(mustMatch[field]);\n      const commonValues = intersection(mustNotMatchValues, mustMatchValues);\n      if (commonValues.size > 0) {\n        console.error(\n          `Conflicting match conditions for field ${field}, the template will be ignored.`,\n          commonValues\n        );\n        return [() => false];\n      }\n    }\n    conditions.push(\n      ProductTemplatesHelpers.fieldMustMatch(field, mustMatch[field])\n    );\n  }\n\n  for (const field in mustNotMatch) {\n    conditions.push(\n      ProductTemplatesHelpers.fieldMustNotMatch(field, mustNotMatch[field])\n    );\n  }\n  return conditions;\n}\n\nexport function makeDefinedConditions(\n  ifDefined?: string,\n  ifNotDefined?: string\n): ProductTemplateCondition[] {\n  const conditions: ProductTemplateCondition[] = [];\n  if (ifDefined) {\n    const fieldNames = ifDefined.split(',');\n    conditions.push(ProductTemplatesHelpers.fieldsMustBeDefined(fieldNames));\n  }\n\n  if (ifNotDefined) {\n    const fieldNames = ifNotDefined.split(',');\n    conditions.push(ProductTemplatesHelpers.fieldsMustNotBeDefined(fieldNames));\n  }\n  return conditions;\n}\n","import {aggregate, isElementNode, isVisualNode} from '@/src/utils/utils';\nimport {\n  ProductTemplate,\n  ProductTemplateCondition,\n  ProductTemplatesHelpers,\n} from '@coveo/headless/commerce';\nimport {h} from '@stencil/core';\nimport {tableElementTagName} from '../../search/atomic-table-result/table-element-utils';\nimport {ItemTarget} from '../layout/display-options';\nimport {isResultSectionNode} from '../layout/sections';\n\nexport {makeMatchConditions} from './product-template-common';\n\nexport type TemplateContent = DocumentFragment;\n\ninterface ProductTemplateCommonProps {\n  allowEmpty?: boolean;\n  host: HTMLDivElement;\n  validParents: string[];\n  setError: (error: Error) => void;\n}\n\ntype TemplateNodeType =\n  | 'section'\n  | 'metadata'\n  | 'table-column-definition'\n  | 'other';\n\nexport function getTemplateNodeType(node: Node): TemplateNodeType {\n  if (isResultSectionNode(node)) {\n    return 'section';\n  }\n  if (!isVisualNode(node)) {\n    return 'metadata';\n  }\n  if (\n    isElementNode(node) &&\n    node.tagName.toLowerCase() === tableElementTagName\n  ) {\n    return 'table-column-definition';\n  }\n  return 'other';\n}\n\nfunction groupNodesByType(nodes: NodeList) {\n  return aggregate(Array.from(nodes), (node) => getTemplateNodeType(node));\n}\n\n/**\n * @deprecated Use `ProductTemplateController` Reactive controller instead.\n */\nexport class ProductTemplateCommon {\n  private host: HTMLDivElement;\n  public matchConditions: ProductTemplateCondition[] = [];\n  private gridCellLinkTarget?: ItemTarget;\n\n  constructor({\n    host,\n    setError,\n    validParents,\n    allowEmpty = false,\n  }: ProductTemplateCommonProps) {\n    this.host = host;\n    this.validateTemplate(host, setError, validParents, allowEmpty);\n  }\n\n  validateTemplate(\n    host: HTMLDivElement,\n    setError: (error: Error) => void,\n    validParents: string[],\n    allowEmpty = true\n  ) {\n    const hasValidParent = validParents\n      .map((p) => p.toUpperCase())\n      .includes(host.parentElement?.nodeName || '');\n    const tagName = host.nodeName.toLowerCase();\n\n    if (!hasValidParent) {\n      setError(\n        new Error(\n          `The \"${tagName}\" component has to be the child of one of the following: ${validParents\n            .map((p) => `\"${p.toLowerCase()}\"`)\n            .join(', ')}.`\n        )\n      );\n      return;\n    }\n\n    if (\n      host.parentElement?.attributes.getNamedItem('display')?.value === 'grid'\n    ) {\n      this.gridCellLinkTarget = host.parentElement?.attributes.getNamedItem(\n        'grid-cell-link-target'\n      )?.value as ItemTarget;\n    }\n\n    const template = host.querySelector('template');\n    if (!template) {\n      setError(\n        new Error(\n          `The \"${tagName}\" component must contain a \"template\" element as a child.`\n        )\n      );\n      return;\n    }\n\n    if (!allowEmpty && !template.innerHTML.trim()) {\n      setError(\n        new Error(`The \"template\" tag inside \"${tagName}\" cannot be empty.`)\n      );\n      return;\n    }\n\n    if (template.content.querySelector('script')) {\n      console.warn(\n        'Any \"script\" tags defined inside of \"template\" elements are not supported and will not be executed when the products are rendered.',\n        host\n      );\n    }\n\n    const {section: sectionNodes, other: otherNodes} = groupNodesByType(\n      template.content.childNodes\n    );\n    if (sectionNodes?.length && otherNodes?.length) {\n      console.warn(\n        'Product templates should only contain section elements or non-section elements. Future updates could unpredictably affect this product template.',\n        host,\n        {sectionNodes, otherNodes}\n      );\n    }\n  }\n\n  getTemplate(\n    conditions: ProductTemplateCondition[],\n    error: Error\n  ): ProductTemplate<TemplateContent> | null {\n    if (error) {\n      return null;\n    }\n\n    return {\n      conditions: conditions.concat(this.matchConditions),\n      content: getTemplateElement(this.host).content!,\n      linkContent: this.getLinkTemplateElement(this.host).content!,\n      priority: 1,\n    };\n  }\n\n  renderIfError(error: Error) {\n    if (error) {\n      return (\n        <atomic-component-error\n          element={this.host}\n          error={error}\n        ></atomic-component-error>\n      );\n    }\n  }\n  getDefaultLinkTemplateElement() {\n    const linkTemplate = document.createElement('template');\n    linkTemplate.innerHTML = `<atomic-product-link>${this.gridCellLinkTarget ? `<a slot=\"attributes\" target=\"${this.gridCellLinkTarget}\"></a>` : ''}</atomic-product-link>`;\n    return linkTemplate;\n  }\n\n  getLinkTemplateElement(host: HTMLElement) {\n    return (\n      host.querySelector<HTMLTemplateElement>('template[slot=\"link\"]') ??\n      this.getDefaultLinkTemplateElement()\n    );\n  }\n}\n\nfunction getTemplateElement(host: HTMLElement) {\n  return host.querySelector<HTMLTemplateElement>('template:not([slot])')!;\n}\n\nexport function makeDefinedConditions(\n  ifDefined?: string,\n  ifNotDefined?: string\n): ProductTemplateCondition[] {\n  const conditions: ProductTemplateCondition[] = [];\n  if (ifDefined) {\n    const fieldNames = ifDefined.split(',');\n    conditions.push(ProductTemplatesHelpers.fieldsMustBeDefined(fieldNames));\n  }\n\n  if (ifNotDefined) {\n    const fieldNames = ifNotDefined.split(',');\n    conditions.push(ProductTemplatesHelpers.fieldsMustNotBeDefined(fieldNames));\n  }\n  return conditions;\n}\n"],"mappings":"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","ignoreList":[]}