{"version":3,"names":["shouldDisplayInputForFacetRange","facetRange","hasInput","hasInputRange","searchStatusState","facetValues","hasResults","onlyValuesWithResultsOrActive","filter","value","numberOfResults","state","length","sortFacetVisibility","facetElements","facetInfoMap","visibleFacets","invisibleFacets","forEach","facet","facetId","isHidden","push","collapseFacetsAfter","facets","visibleFacetsCount","index","isCollapsed","isAutomaticFacetGenerator","element","tagName","isPseudoFacet","el","getFacetsInChildren","parent","Array","from","children","child","getAutomaticFacetGenerator","find","findFacetParent","parents","i","contains","triageFacetsByParents","sortedFacets","Map","concat","map","get"],"sources":["src/components/common/facets/stencil-facet-common.tsx"],"sourcesContent":["import {FacetValue, SearchStatusState} from '@coveo/headless';\nimport {i18n} from 'i18next';\n\nexport interface FacetValueProps {\n  i18n: i18n;\n  displayValue: string;\n  numberOfResults: number;\n  isSelected: boolean;\n  onClick(): void;\n  searchQuery?: string;\n  class?: string;\n  part?: string;\n  additionalPart?: string;\n  buttonRef?: (element?: HTMLButtonElement) => void;\n}\n\nexport function shouldDisplayInputForFacetRange(facetRange: {\n  hasInput: boolean;\n  hasInputRange: boolean;\n  searchStatusState: SearchStatusState;\n  facetValues: Pick<FacetValue, 'numberOfResults' | 'state'>[];\n}) {\n  const {hasInput, hasInputRange, searchStatusState, facetValues} = facetRange;\n  if (!hasInput) {\n    return false;\n  }\n\n  if (hasInputRange) {\n    return true;\n  }\n\n  if (!searchStatusState.hasResults) {\n    return false;\n  }\n\n  const onlyValuesWithResultsOrActive =\n    facetValues.filter(\n      (value) => value.numberOfResults || value.state !== 'idle'\n    ) || [];\n\n  if (!onlyValuesWithResultsOrActive.length) {\n    return false;\n  }\n\n  return true;\n}\n\nexport type BaseFacetElement = HTMLElement & {\n  facetId: string;\n  isCollapsed: boolean;\n};\n\nexport function sortFacetVisibility(\n  facetElements: BaseFacetElement[],\n  facetInfoMap: Record<string, {isHidden: () => boolean}>\n) {\n  const visibleFacets: BaseFacetElement[] = [];\n  const invisibleFacets: BaseFacetElement[] = [];\n\n  facetElements.forEach((facet) => {\n    if (facetInfoMap[facet.facetId] && facetInfoMap[facet.facetId].isHidden()) {\n      invisibleFacets.push(facet);\n    } else {\n      visibleFacets.push(facet);\n    }\n  });\n\n  return {visibleFacets, invisibleFacets};\n}\n\nexport function collapseFacetsAfter(\n  facets: BaseFacetElement[],\n  visibleFacetsCount: number\n) {\n  if (visibleFacetsCount === -1) {\n    return;\n  }\n\n  facets.forEach((facet, index) => {\n    facet.isCollapsed = index + 1 > visibleFacetsCount;\n  });\n}\n\nexport function isAutomaticFacetGenerator(\n  element: HTMLElement\n): element is HTMLAtomicAutomaticFacetGeneratorElement {\n  return element.tagName === 'ATOMIC-AUTOMATIC-FACET-GENERATOR';\n}\n\nfunction isPseudoFacet(el: Element): el is BaseFacetElement {\n  return 'facetId' in el;\n}\n\nexport function getFacetsInChildren(parent: HTMLElement): BaseFacetElement[] {\n  const facets = Array.from(parent.children).filter((child) =>\n    isPseudoFacet(child)\n  ) as BaseFacetElement[];\n\n  return facets;\n}\nexport function getAutomaticFacetGenerator(\n  parent: HTMLElement\n): HTMLAtomicAutomaticFacetGeneratorElement | undefined {\n  return (Array.from(parent.children) as HTMLElement[]).find(\n    isAutomaticFacetGenerator\n  );\n}\n\nfunction findFacetParent(\n  facet: BaseFacetElement,\n  parents: (HTMLElement | null)[]\n) {\n  for (let i = 0; i < parents.length; i++) {\n    if (parents[i]?.contains(facet)) {\n      return parents[i];\n    }\n  }\n  return null;\n}\n\n/**\n * Triage elements by their parents.\n * @param facets Facet Elements\n * @param parents Elements that may contains the facets\n * @returns an array in the same order as the parents, containing the facets that are contained by the corresponding parent.\n * The last element of the array contains the facets that are not contained by any of the parents.\n */\nexport function triageFacetsByParents(\n  facets: BaseFacetElement[],\n  ...parents: (HTMLElement | null)[]\n): Map<HTMLElement | null, BaseFacetElement[]> {\n  const sortedFacets: Map<HTMLElement | null, BaseFacetElement[]> = new Map(\n    parents.concat([null]).map((parent) => [parent, []])\n  );\n  for (const facet of facets) {\n    const parent = findFacetParent(facet, parents);\n    sortedFacets.get(parent)!.push(facet);\n  }\n  return sortedFacets;\n}\n"],"mappings":"SAgBgBA,EAAgCC,GAM9C,MAAMC,SAACA,EAAQC,cAAEA,EAAaC,kBAAEA,EAAiBC,YAAEA,GAAeJ,EAClE,IAAKC,EAAU,CACb,OAAO,K,CAGT,GAAIC,EAAe,CACjB,OAAO,I,CAGT,IAAKC,EAAkBE,WAAY,CACjC,OAAO,K,CAGT,MAAMC,EACJF,EAAYG,QACTC,GAAUA,EAAMC,iBAAmBD,EAAME,QAAU,UACjD,GAEP,IAAKJ,EAA8BK,OAAQ,CACzC,OAAO,K,CAGT,OAAO,IACT,C,SAOgBC,EACdC,EACAC,GAEA,MAAMC,EAAoC,GAC1C,MAAMC,EAAsC,GAE5CH,EAAcI,SAASC,IACrB,GAAIJ,EAAaI,EAAMC,UAAYL,EAAaI,EAAMC,SAASC,WAAY,CACzEJ,EAAgBK,KAAKH,E,KAChB,CACLH,EAAcM,KAAKH,E,KAIvB,MAAO,CAACH,gBAAeC,kBACzB,C,SAEgBM,EACdC,EACAC,GAEA,GAAIA,KAAwB,EAAG,CAC7B,M,CAGFD,EAAON,SAAQ,CAACC,EAAOO,KACrBP,EAAMQ,YAAcD,EAAQ,EAAID,CAAkB,GAEtD,C,SAEgBG,EACdC,GAEA,OAAOA,EAAQC,UAAY,kCAC7B,CAEA,SAASC,EAAcC,GACrB,MAAO,YAAaA,CACtB,C,SAEgBC,EAAoBC,GAClC,MAAMV,EAASW,MAAMC,KAAKF,EAAOG,UAAU7B,QAAQ8B,GACjDP,EAAcO,KAGhB,OAAOd,CACT,C,SACgBe,EACdL,GAEA,OAAQC,MAAMC,KAAKF,EAAOG,UAA4BG,KACpDZ,EAEJ,CAEA,SAASa,EACPtB,EACAuB,GAEA,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAQ9B,OAAQ+B,IAAK,CACvC,GAAID,EAAQC,IAAIC,SAASzB,GAAQ,CAC/B,OAAOuB,EAAQC,E,EAGnB,OAAO,IACT,C,SASgBE,EACdrB,KACGkB,GAEH,MAAMI,EAA4D,IAAIC,IACpEL,EAAQM,OAAO,CAAC,OAAOC,KAAKf,GAAW,CAACA,EAAQ,OAElD,IAAK,MAAMf,KAASK,EAAQ,CAC1B,MAAMU,EAASO,EAAgBtB,EAAOuB,GACtCI,EAAaI,IAAIhB,GAASZ,KAAKH,E,CAEjC,OAAO2B,CACT,Q","ignoreList":[]}