{"file":"formatter.js","mappings":";;MAqBa,mBAAmB,GAAG,CAAC,EAClC,YAAY,EACZ,KAAK,EACL,IAAI,EACJ,UAAU,EACV,MAAM,EACN,SAAS,GACa;IACtB,MAAM,gBAAgB,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC,KAAK,KAC/C,cAAc,CAAC,KAAK,EAAE,UAAU,CAAC,CAClC,EAAE,KAAK,CAAC;IACT,OAAO,gBAAgB;UACnB,oBAAoB,CAAC,KAAK,EAAE,gBAAgB,EAAE,IAAI,CAAC;UACnD,IAAI,CAAC,CAAC,CAAC,IAAI,EAAE;YACX,KAAK,EAAE,qBAAqB,CAAC,UAAU,CAAC,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,SAAS,CAAC;YACvE,GAAG,EAAE,qBAAqB,CAAC,UAAU,CAAC,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,SAAS,CAAC;SACpE,CAAC,CAAC;AACT,EAAE;AAEK,MAAM,qBAAqB,GAAG,CACnC,KAAa,EACb,IAAmC,EACnC,MAAuC,EACvC,SAA6C;IAE7C,IAAI;QACF,OAAO,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC,SAAqB,CAAC,CAAC;KACrD;IAAC,OAAO,KAAK,EAAE;QACd,MAAM,CAAC,KAAK,CACV,qCAAqC,KAAK,qCAAqC,EAC/E,KAAK,CACN,CAAC;QACF,OAAO,KAAK,CAAC;KACd;AACH,CAAC,CAAC;AAEF,MAAM,cAAc,GAAG,CACrB,UAA2B,EAC3B,WAA4B;IAE5B,QACE,UAAU,CAAC,KAAK,KAAK,WAAW,CAAC,KAAK;QACtC,UAAU,CAAC,GAAG,KAAK,WAAW,CAAC,GAAG;QAClC,UAAU,CAAC,YAAY,KAAK,WAAW,CAAC,YAAY,EACpD;AACJ,CAAC;;;;","names":[],"sources":["src/components/common/facets/numeric-facet/formatter.ts"],"sourcesContent":["import {i18n} from 'i18next';\nimport {getFieldValueCaption} from '../../../../utils/field-utils';\nimport {NumberFormatter} from '../../formats/format-common';\n\nexport interface FacetValueRange {\n  endInclusive: boolean;\n  start: number;\n  end: number;\n  label?: string;\n  state: 'selected' | 'idle' | 'excluded';\n}\n\nexport interface FormatFacetValueRange {\n  field: string;\n  facetValue: FacetValueRange & {numberOfResults: number};\n  manualRanges: FacetValueRange[];\n  i18n: i18n;\n  logger: Pick<Console, 'error'>;\n  formatter: NumberFormatter;\n}\n\nexport const formatHumanReadable = ({\n  manualRanges,\n  field,\n  i18n,\n  facetValue,\n  logger,\n  formatter,\n}: FormatFacetValueRange) => {\n  const manualRangeLabel = manualRanges.find((range) =>\n    areRangesEqual(range, facetValue)\n  )?.label;\n  return manualRangeLabel\n    ? getFieldValueCaption(field, manualRangeLabel, i18n)\n    : i18n.t('to', {\n        start: formatNumberLocalized(facetValue.start, i18n, logger, formatter),\n        end: formatNumberLocalized(facetValue.end, i18n, logger, formatter),\n      });\n};\n\nexport const formatNumberLocalized = (\n  value: number,\n  i18n: FormatFacetValueRange['i18n'],\n  logger: FormatFacetValueRange['logger'],\n  formatter: FormatFacetValueRange['formatter']\n) => {\n  try {\n    return formatter(value, i18n.languages as string[]);\n  } catch (error) {\n    logger.error(\n      `atomic-numeric-facet facet value \"${value}\" could not be formatted correctly.`,\n      error\n    );\n    return value;\n  }\n};\n\nconst areRangesEqual = (\n  firstRange: FacetValueRange,\n  secondRange: FacetValueRange\n) => {\n  return (\n    firstRange.start === secondRange.start &&\n    firstRange.end === secondRange.end &&\n    firstRange.endInclusive === secondRange.endInclusive\n  );\n};\n"],"version":3}