{"file":"atomic-product-field-condition.js","mappings":";;;;;;;;;;;;;;;MAkBaA,6BAA2B;;;;;;;;QAgBA,cAAS,GAC7C,EAAE,CAAC;;;;;QAMiC,iBAAY,GAChD,EAAE,CAAC;QAEG,eAAU,GAA+B,EAAE,CAAC;QAC5C,oBAAe,GAAG,KAAK,CAAC;;;yBAV9B,EAAE;4BAOF,EAAE;;IAOG,iBAAiB;QACtB,IAAI,CAAC,UAAU,GAAG,qBAAqB,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;QAC3E,IAAI,CAAC,UAAU,CAAC,IAAI,CAClB,GAAG,mBAAmB,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,YAAY,CAAC,CAC1D,CAAC;KACH;IAEM,MAAM;QACX,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,SAAS,KAAK,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,EAAE;YAClE,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;YAC5B,OAAO,EAAE,CAAC;SACX;QAED,OAAO,eAAQ,CAAC;KACjB;IAEM,gBAAgB;QACrB,IAAI,CAAC,eAAe,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC;KAC5C;;;;;;;;AAjCqC;IAA7B,OAAO,CAAC,EAAC,WAAW,EAAE,IAAI,EAAC,CAAC;gEAChC;AAMiC;IAA7B,OAAO,CAAC,EAAC,WAAW,EAAE,IAAI,EAAC,CAAC;mEAChC;AAKqB;IAAzB,cAAc,EAAE;8DAA2B;;;;;;;;;;;;;;;;;;;;","names":["AtomicProductFieldCondition"],"sources":["src/components/commerce/product-template-components/atomic-product-field-condition/atomic-product-field-condition.tsx"],"sourcesContent":["import {Product, ProductTemplateCondition} from '@coveo/headless/commerce';\nimport {Component, Prop, h, Element} from '@stencil/core';\nimport {MapProp} from '../../../../utils/props-utils';\nimport {\n  makeDefinedConditions,\n  makeMatchConditions,\n} from '../../../common/product-template/stencil-product-template-common';\nimport {ProductContext} from '../product-template-decorators';\n\n/**\n * The `atomic-product-field-condition` component takes a list of conditions that, if fulfilled, apply the template in which it's defined.\n * The condition properties can be based on any top-level product property of the `product` object, not restricted to fields (e.g., `ec_name`).\n * @alpha\n */\n@Component({\n  tag: 'atomic-product-field-condition',\n  shadow: false,\n})\nexport class AtomicProductFieldCondition {\n  @Element() host!: HTMLElement;\n\n  /**\n   * Verifies whether the specified fields are defined.\n   */\n  @Prop({reflect: true}) ifDefined?: string;\n  /**\n   * Verifies whether the specified fields are not defined.\n   */\n  @Prop({reflect: true}) ifNotDefined?: string;\n\n  /**\n   * Verifies whether the specified fields match the specified values.\n   * @type {Record<string, string[]>}\n   */\n  @Prop() @MapProp({splitValues: true}) mustMatch: Record<string, string[]> =\n    {};\n\n  /**\n   * Verifies whether the specified fields do not match the specified values.\n   * @type {Record<string, string[]>}\n   */\n  @Prop() @MapProp({splitValues: true}) mustNotMatch: Record<string, string[]> =\n    {};\n\n  private conditions: ProductTemplateCondition[] = [];\n  private shouldBeRemoved = false;\n\n  @ProductContext() private product!: Product;\n\n  public componentWillLoad() {\n    this.conditions = makeDefinedConditions(this.ifDefined, this.ifNotDefined);\n    this.conditions.push(\n      ...makeMatchConditions(this.mustMatch, this.mustNotMatch)\n    );\n  }\n\n  public render() {\n    if (!this.conditions.every((condition) => condition(this.product))) {\n      this.shouldBeRemoved = true;\n      return '';\n    }\n\n    return <slot />;\n  }\n\n  public componentDidLoad() {\n    this.shouldBeRemoved && this.host.remove();\n  }\n}\n"],"version":3}