{"version":3,"names":["findAriaLiveEventName","AriaLiveRegion","regionName","assertive","getAriaLiveElement","event","buildCustomEvent","document","dispatchEvent","element","detail","dispatchMessage","message","updateMessage","registerRegion","component","setterName","componentWillRender","Object","defineProperty","set","call","this","FocusTargetController","constructor","doFocusAfterSearch","doFocusOnNextTarget","bindings","handleComponentRenderLoop","setTarget","el","focus","defer","onFocusCallback","focusAfterSearch","lastSearchId","store","getUniqueIDFromEngine","engine","Promise","resolve","focusOnNextTarget","disableForCurrentSearch","originalComponentDidRender","componentDidRender","then","isFocusable","getAttribute","hasAttribute","tagName","getFocusableDescendants","children","Array","from","HTMLSlotElement","assignedElements","shadowRoot","push","child","getFirstFocusableDescendant","next","value"],"sources":["src/utils/stencil-accessibility-utils.tsx"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {AnyBindings} from '../components/common/interface/bindings';\nimport {buildCustomEvent} from './event-utils';\nimport {InitializableComponent} from './initialization-utils';\nimport {defer} from './utils';\n\nconst findAriaLiveEventName = 'atomic/accessibility/findAriaLive';\n\n/**\n * @deprecated use Lit equivalent\n */\nexport interface FindAriaLiveEventArgs {\n  element?: HTMLAtomicAriaLiveElement;\n}\n\n/**\n * @deprecated use Lit equivalent\n */\nexport function AriaLiveRegion(regionName: string, assertive = false) {\n  function getAriaLiveElement() {\n    const event = buildCustomEvent<FindAriaLiveEventArgs>(\n      findAriaLiveEventName,\n      {}\n    );\n    document.dispatchEvent(event);\n    const {element} = event.detail;\n    return element;\n  }\n\n  function dispatchMessage(message: string) {\n    getAriaLiveElement()?.updateMessage(regionName, message, assertive);\n  }\n\n  function registerRegion() {\n    getAriaLiveElement()?.registerRegion(regionName, assertive);\n  }\n\n  return (\n    component: InitializableComponent<AnyBindings>,\n    setterName: string\n  ) => {\n    const {componentWillRender} = component;\n    Object.defineProperty(component, setterName, {\n      set: (message: string) => dispatchMessage(message),\n    });\n\n    component.componentWillRender = function () {\n      componentWillRender && componentWillRender.call(this);\n      registerRegion();\n    };\n  };\n}\n\n/**\n * @deprecated use Lit equivalent\n */\nexport class FocusTargetController {\n  private bindings: AnyBindings;\n  private lastSearchId?: string;\n  private element?: HTMLElement;\n  private onFocusCallback?: Function;\n  private doFocusAfterSearch = false;\n  private doFocusOnNextTarget = false;\n\n  constructor(private component: InitializableComponent<AnyBindings>) {\n    this.bindings = component.bindings;\n    this.handleComponentRenderLoop();\n  }\n\n  public setTarget(el: HTMLElement | undefined) {\n    if (!el) {\n      return;\n    }\n    this.element = el;\n    if (this.doFocusOnNextTarget) {\n      this.doFocusOnNextTarget = false;\n      this.focus();\n    }\n  }\n\n  public async focus() {\n    await defer();\n    this.element?.focus();\n    this.onFocusCallback?.();\n  }\n\n  public focusAfterSearch() {\n    this.lastSearchId = this.bindings.store.getUniqueIDFromEngine(\n      this.bindings.engine\n    );\n    this.doFocusAfterSearch = true;\n    return new Promise((resolve) => (this.onFocusCallback = resolve));\n  }\n\n  public focusOnNextTarget() {\n    this.doFocusOnNextTarget = true;\n    return new Promise((resolve) => (this.onFocusCallback = resolve));\n  }\n\n  public disableForCurrentSearch() {\n    if (\n      this.bindings.store.getUniqueIDFromEngine(this.bindings.engine) !==\n      this.lastSearchId\n    ) {\n      this.doFocusAfterSearch = false;\n    }\n  }\n\n  private handleComponentRenderLoop() {\n    const originalComponentDidRender = this.component.componentDidRender;\n\n    this.component.componentDidRender = () => {\n      originalComponentDidRender &&\n        originalComponentDidRender.call(this.component);\n      if (!this.bindings) {\n        return;\n      }\n      if (\n        this.doFocusAfterSearch &&\n        this.bindings.store.getUniqueIDFromEngine(this.bindings.engine) !==\n          this.lastSearchId\n      ) {\n        this.doFocusAfterSearch = false;\n        if (this.element) {\n          const el = this.element;\n          // The focus seems to be flaky without deferring, especially on iOS.\n          defer().then(() => {\n            el.focus();\n            this.onFocusCallback?.();\n          });\n        }\n      }\n    };\n  }\n}\n\nfunction isFocusable(element: Element) {\n  // Source: https://stackoverflow.com/a/30753870\n  if (element.getAttribute('tabindex') === '-1') {\n    return false;\n  }\n  if (element.hasAttribute('tabindex')) {\n    return true;\n  }\n  if (element.getAttribute('contentEditable') === 'true') {\n    return true;\n  }\n  switch (element.tagName) {\n    case 'A':\n    case 'AREA':\n      return element.hasAttribute('href');\n    case 'INPUT':\n    case 'SELECT':\n    case 'TEXTAREA':\n    case 'BUTTON':\n      return !element.hasAttribute('disabled');\n    case 'IFRAME':\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * @deprecated use Lit equivalent\n */\nexport function* getFocusableDescendants(\n  element: Element\n): Generator<HTMLElement> {\n  if (isFocusable(element)) {\n    yield element as HTMLElement;\n  }\n  let children = Array.from(element.children);\n  if (element instanceof HTMLSlotElement) {\n    children = element.assignedElements();\n  } else if (element.shadowRoot) {\n    children.push(...Array.from(element.shadowRoot.children));\n  }\n  for (const child of children) {\n    yield* getFocusableDescendants(child);\n  }\n}\n\n/**\n * @deprecated use Lit equivalent\n */\nexport function getFirstFocusableDescendant(\n  element: Element\n): HTMLElement | null {\n  return getFocusableDescendants(element).next().value ?? null;\n}\n"],"mappings":"wEAMA,MAAMA,EAAwB,oC,SAYdC,EAAeC,EAAoBC,EAAY,OAC7D,SAASC,IACP,MAAMC,EAAQC,EACZN,EACA,IAEFO,SAASC,cAAcH,GACvB,MAAMI,QAACA,GAAWJ,EAAMK,OACxB,OAAOD,C,CAGT,SAASE,EAAgBC,GACvBR,KAAsBS,cAAcX,EAAYU,EAAST,E,CAG3D,SAASW,IACPV,KAAsBU,eAAeZ,EAAYC,E,CAGnD,MAAO,CACLY,EACAC,KAEA,MAAMC,oBAACA,GAAuBF,EAC9BG,OAAOC,eAAeJ,EAAWC,EAAY,CAC3CI,IAAMR,GAAoBD,EAAgBC,KAG5CG,EAAUE,oBAAsB,WAC9BA,GAAuBA,EAAoBI,KAAKC,MAChDR,G,CACD,CAEL,C,MAKaS,EAQX,WAAAC,CAAoBT,GAAAO,KAAAP,YAHZO,KAAAG,mBAAqB,MACrBH,KAAAI,oBAAsB,MAG5BJ,KAAKK,SAAWZ,EAAUY,SAC1BL,KAAKM,2B,CAGA,SAAAC,CAAUC,GACf,IAAKA,EAAI,CACP,M,CAEFR,KAAKb,QAAUqB,EACf,GAAIR,KAAKI,oBAAqB,CAC5BJ,KAAKI,oBAAsB,MAC3BJ,KAAKS,O,EAIF,WAAMA,SACLC,IACNV,KAAKb,SAASsB,QACdT,KAAKW,mB,CAGA,gBAAAC,GACLZ,KAAKa,aAAeb,KAAKK,SAASS,MAAMC,sBACtCf,KAAKK,SAASW,QAEhBhB,KAAKG,mBAAqB,KAC1B,OAAO,IAAIc,SAASC,GAAalB,KAAKW,gBAAkBO,G,CAGnD,iBAAAC,GACLnB,KAAKI,oBAAsB,KAC3B,OAAO,IAAIa,SAASC,GAAalB,KAAKW,gBAAkBO,G,CAGnD,uBAAAE,GACL,GACEpB,KAAKK,SAASS,MAAMC,sBAAsBf,KAAKK,SAASW,UACxDhB,KAAKa,aACL,CACAb,KAAKG,mBAAqB,K,EAItB,yBAAAG,GACN,MAAMe,EAA6BrB,KAAKP,UAAU6B,mBAElDtB,KAAKP,UAAU6B,mBAAqB,KAClCD,GACEA,EAA2BtB,KAAKC,KAAKP,WACvC,IAAKO,KAAKK,SAAU,CAClB,M,CAEF,GACEL,KAAKG,oBACLH,KAAKK,SAASS,MAAMC,sBAAsBf,KAAKK,SAASW,UACtDhB,KAAKa,aACP,CACAb,KAAKG,mBAAqB,MAC1B,GAAIH,KAAKb,QAAS,CAChB,MAAMqB,EAAKR,KAAKb,QAEhBuB,IAAQa,MAAK,KACXf,EAAGC,QACHT,KAAKW,mBAAmB,G,KAQpC,SAASa,EAAYrC,GAEnB,GAAIA,EAAQsC,aAAa,cAAgB,KAAM,CAC7C,OAAO,K,CAET,GAAItC,EAAQuC,aAAa,YAAa,CACpC,OAAO,I,CAET,GAAIvC,EAAQsC,aAAa,qBAAuB,OAAQ,CACtD,OAAO,I,CAET,OAAQtC,EAAQwC,SACd,IAAK,IACL,IAAK,OACH,OAAOxC,EAAQuC,aAAa,QAC9B,IAAK,QACL,IAAK,SACL,IAAK,WACL,IAAK,SACH,OAAQvC,EAAQuC,aAAa,YAC/B,IAAK,SACH,OAAO,KACT,QACE,OAAO,MAEb,C,SAKiBE,EACfzC,GAEA,GAAIqC,EAAYrC,GAAU,OAClBA,C,CAER,IAAI0C,EAAWC,MAAMC,KAAK5C,EAAQ0C,UAClC,GAAI1C,aAAmB6C,gBAAiB,CACtCH,EAAW1C,EAAQ8C,kB,MACd,GAAI9C,EAAQ+C,WAAY,CAC7BL,EAASM,QAAQL,MAAMC,KAAK5C,EAAQ+C,WAAWL,U,CAEjD,IAAK,MAAMO,KAASP,EAAU,OACrBD,EAAwBQ,E,CAEnC,C,SAKgBC,EACdlD,GAEA,OAAOyC,EAAwBzC,GAASmD,OAAOC,OAAS,IAC1D,Q","ignoreList":[]}