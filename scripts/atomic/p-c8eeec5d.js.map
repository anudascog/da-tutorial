{"version":3,"names":["searchBoxElements","isLitElementLoosely","candidate","Promise","dispatchSearchBoxSuggestionsEventEventually","async","interfaceElement","element","event","updateComplete","componentOnReady","dispatchEvent","buildCustomEvent","dispatchSearchBoxSuggestionsEvent","allowedSearchBoxElements","closest","join","Error","nodeName","toLowerCase","elementHasNoQuery","el","query","elementHasQuery"],"sources":["src/components/common/suggestions/suggestions-common.ts"],"sourcesContent":["import {VNode} from '@stencil/core';\nimport {HTMLStencilElement} from '@stencil/core/internal';\nimport type {LitElement} from 'lit';\nimport {closest} from '../../../utils/dom-utils';\nimport {buildCustomEvent} from '../../../utils/event-utils';\nimport {AnyBindings} from '../interface/bindings';\n\n/**\n * Element which will be rendered in the list of suggestions.\n */\nexport interface SearchBoxSuggestionElement {\n  /**\n   * Stable identity which enables Stencil to reuse DOM elements for better performance.\n   * The best way to pick a key is to use a string that uniquely identifies that list item among its siblings (often your data will already have IDs).\n   */\n  key: string;\n  /**\n   * Rendered content of the element.\n   *\n   * @remarks\n   * The `VNode` type will be deprecated in v4 as we are detaching from Stencil.\n   */\n  content: Element | VNode;\n  /**\n   * Hook called when the selection is selected.\n   * @param e DOM event.\n   */\n  onSelect?(e: Event): void;\n  /**\n   * The query associated with the suggestion which will replace the query in the search box if the suggestion is selected.\n   */\n  query?: string;\n  /**\n   * For improved accessibility, provide this property with additional information.\n   * https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-label\n   */\n  ariaLabel?: string;\n  /**\n   * Adds a specific shadow part attribute that can be selected with the CSS ::part pseudo-element.\n   * https://developer.mozilla.org/en-US/docs/Web/CSS/::part\n   */\n  part?: string;\n  /**\n   * Hide the suggestion if it's the last in the list.\n   */\n  hideIfLast?: boolean;\n}\n\n/**\n * List of suggestions that will be displayed along other lists (e.g recent queries) when the search box's input is selected.\n */\nexport interface SearchBoxSuggestions {\n  /**\n   * The search box will sort the position of suggestions using this value. The lowest value being first.\n   * By default, the DOM position will be used.\n   */\n  position: number;\n  /**\n   * Whether the suggestions should be listed in the right or left panel. By default, the suggestions are listed in the right panel.\n   */\n  panel?: 'left' | 'right';\n  /**\n   * Method that returns the list of elements which will be rendered in the list of suggestions.\n   */\n  renderItems(): SearchBoxSuggestionElement[];\n  /**\n   * Hook called when the user changes the search box's input value. This can lead to all the query suggestions being updated.\n   */\n  onInput?(): Promise<unknown> | void;\n  /**\n   * Hook called when the suggested query changes as a user traverses through the list of suggestions.\n   * This is used for instant results, which are rendered based on the current suggested query.\n   * @param q The new suggested query.\n   */\n  onSuggestedQueryChange?(q: string): Promise<unknown> | void;\n}\n\n/**\n * Event sent from the registered query suggestions to the parent search box.\n */\nexport type SearchBoxSuggestionsEvent<\n  SearchBoxController,\n  Bindings = AnyBindings,\n> = (\n  /**\n   * The bindings passed from the search box to the suggestions.\n   */\n  bindings: SearchBoxSuggestionsBindings<SearchBoxController, Bindings>\n) => SearchBoxSuggestions;\n\nconst searchBoxElements = [\n  'atomic-search-box',\n  'atomic-insight-search-box',\n  'atomic-commerce-search-box',\n] as const;\n\n/**\n * The bindings passed from the search box to the suggestions.\n */\nexport type SearchBoxSuggestionsBindings<\n  SearchBoxController,\n  Bindings = AnyBindings,\n> = Bindings & {\n  /**\n   * The unique id of the search box.\n   */\n  id: string;\n  /**\n   * Whether the search box is [standalone](https://docs.coveo.com/en/atomic/latest/usage/ssb/).\n   */\n  isStandalone: boolean;\n  /**\n   * The search box headless controller.\n   */\n  searchBoxController: SearchBoxController;\n  /**\n   * The number of queries to display when the user interacts with the search box.\n   */\n  numberOfQueries: number;\n  /**\n   * Whether to clear all active query filters when the end user submits a new query from the search box.\n   */\n  clearFilters: boolean;\n  /**\n   * Retrieves the suggested query, meaning the query that would be sent if the search is executed.\n   * The suggested query changes as a user traverses through the list of suggestions.\n   */\n  suggestedQuery(): string;\n  /**\n   * Removes the current suggestions.\n   */\n  clearSuggestions(): void;\n  /**\n   * Triggers update & retrieval of all suggestions.\n   */\n  triggerSuggestions(): void;\n  /**\n   * Retrieves the current suggestions.\n   */\n  getSuggestions(): SearchBoxSuggestions[];\n  /**\n   * Retrieves the current suggestions elements.\n   */\n  getSuggestionElements(): SearchBoxSuggestionElement[];\n};\n\nconst isLitElementLoosely = (candidate: unknown): candidate is LitElement =>\n  'updateComplete' in (candidate as LitElement) &&\n  (candidate as LitElement)['updateComplete'] instanceof Promise;\n\nconst dispatchSearchBoxSuggestionsEventEventually = async <\n  SearchBoxController,\n  Bindings = AnyBindings,\n>(\n  interfaceElement: Element,\n  element: HTMLElement,\n  event: SearchBoxSuggestionsEvent<SearchBoxController, Bindings>\n) => {\n  if (isLitElementLoosely(interfaceElement)) {\n    await interfaceElement.updateComplete;\n  } else if ('componentOnReady' in interfaceElement) {\n    await (interfaceElement as HTMLStencilElement).componentOnReady();\n  }\n  element.dispatchEvent(\n    buildCustomEvent('atomic/searchBoxSuggestion/register', event)\n  );\n};\n\n/**\n * Dispatches an event which retrieves the `SearchBoxSuggestionsBindings` on a configured parent search box.\n * @param event Event sent from the registered query suggestions to the parent search box.\n * @param element Element on which to dispatch the event, which must be the child of a configured search box.\n */\nexport const dispatchSearchBoxSuggestionsEvent = <\n  SearchBoxController,\n  Bindings = AnyBindings,\n>(\n  event: SearchBoxSuggestionsEvent<SearchBoxController, Bindings>,\n  element: HTMLElement,\n  allowedSearchBoxElements: readonly (typeof searchBoxElements)[number][] = searchBoxElements\n) => {\n  const interfaceElement = closest(element, searchBoxElements.join(', '));\n  if (!interfaceElement) {\n    throw new Error(\n      `The \"${element.nodeName.toLowerCase()}\" component was not handled, as it is not a child of the following elements: ${allowedSearchBoxElements.join(\n        ', '\n      )}`\n    );\n  }\n  dispatchSearchBoxSuggestionsEventEventually(interfaceElement, element, event);\n};\n\nexport function elementHasNoQuery(el: SearchBoxSuggestionElement) {\n  return !el.query;\n}\n\nexport function elementHasQuery(el: SearchBoxSuggestionElement) {\n  return !!el.query;\n}\n"],"mappings":"wEA0FA,MAAMA,EAAoB,CACxB,oBACA,4BACA,8BAqDF,MAAMC,EAAuBC,GAC3B,mBAAqBA,GACpBA,EAAyB,4BAA6BC,QAEzD,MAAMC,EAA8CC,MAIlDC,EACAC,EACAC,KAEA,GAAIP,EAAoBK,GAAmB,OACnCA,EAAiBG,c,MAClB,GAAI,qBAAsBH,EAAkB,OAC1CA,EAAwCI,kB,CAEjDH,EAAQI,cACNC,EAAiB,sCAAuCJ,GACzD,E,MAQUK,EAAoC,CAI/CL,EACAD,EACAO,EAA0Ed,KAE1E,MAAMM,EAAmBS,EAAQR,EAASP,EAAkBgB,KAAK,OACjE,IAAKV,EAAkB,CACrB,MAAM,IAAIW,MACR,QAAQV,EAAQW,SAASC,6FAA6FL,EAAyBE,KAC7I,Q,CAINZ,EAA4CE,EAAkBC,EAASC,EAAM,E,SAG/DY,EAAkBC,GAChC,OAAQA,EAAGC,KACb,C,SAEgBC,EAAgBF,GAC9B,QAASA,EAAGC,KACd,Q","ignoreList":[]}