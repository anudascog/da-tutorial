{"file":"suggestions-common.js","mappings":";;;AA0FA,MAAM,iBAAiB,GAAG;IACxB,mBAAmB;IACnB,2BAA2B;IAC3B,4BAA4B;CACpB,CAAC;AAoDX,MAAM,mBAAmB,GAAG,CAAC,SAAkB,KAC7C,gBAAgB,IAAK,SAAwB;IAC5C,SAAwB,CAAC,gBAAgB,CAAC,YAAY,OAAO,CAAC;AAEjE,MAAM,2CAA2C,GAAG,OAIlD,gBAAyB,EACzB,OAAoB,EACpB,KAA+D;IAE/D,IAAI,mBAAmB,CAAC,gBAAgB,CAAC,EAAE;QACzC,MAAM,gBAAgB,CAAC,cAAc,CAAC;KACvC;SAAM,IAAI,kBAAkB,IAAI,gBAAgB,EAAE;QACjD,MAAO,gBAAuC,CAAC,gBAAgB,EAAE,CAAC;KACnE;IACD,OAAO,CAAC,aAAa,CACnB,gBAAgB,CAAC,qCAAqC,EAAE,KAAK,CAAC,CAC/D,CAAC;AACJ,CAAC,CAAC;AAEF;;;;;MAKa,iCAAiC,GAAG,CAI/C,KAA+D,EAC/D,OAAoB,EACpB,2BAA0E,iBAAiB;IAE3F,MAAM,gBAAgB,GAAG,OAAO,CAAC,OAAO,EAAE,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IACxE,IAAI,CAAC,gBAAgB,EAAE;QACrB,MAAM,IAAI,KAAK,CACb,QAAQ,OAAO,CAAC,QAAQ,CAAC,WAAW,EAAE,gFAAgF,wBAAwB,CAAC,IAAI,CACjJ,IAAI,CACL,EAAE,CACJ,CAAC;KACH;IACD,2CAA2C,CAAC,gBAAgB,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;AAChF,EAAE;SAEc,iBAAiB,CAAC,EAA8B;IAC9D,OAAO,CAAC,EAAE,CAAC,KAAK,CAAC;AACnB,CAAC;SAEe,eAAe,CAAC,EAA8B;IAC5D,OAAO,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC;AACpB;;;;","names":[],"sources":["src/components/common/suggestions/suggestions-common.ts"],"sourcesContent":["import {VNode} from '@stencil/core';\nimport {HTMLStencilElement} from '@stencil/core/internal';\nimport type {LitElement} from 'lit';\nimport {closest} from '../../../utils/dom-utils';\nimport {buildCustomEvent} from '../../../utils/event-utils';\nimport {AnyBindings} from '../interface/bindings';\n\n/**\n * Element which will be rendered in the list of suggestions.\n */\nexport interface SearchBoxSuggestionElement {\n  /**\n   * Stable identity which enables Stencil to reuse DOM elements for better performance.\n   * The best way to pick a key is to use a string that uniquely identifies that list item among its siblings (often your data will already have IDs).\n   */\n  key: string;\n  /**\n   * Rendered content of the element.\n   *\n   * @remarks\n   * The `VNode` type will be deprecated in v4 as we are detaching from Stencil.\n   */\n  content: Element | VNode;\n  /**\n   * Hook called when the selection is selected.\n   * @param e DOM event.\n   */\n  onSelect?(e: Event): void;\n  /**\n   * The query associated with the suggestion which will replace the query in the search box if the suggestion is selected.\n   */\n  query?: string;\n  /**\n   * For improved accessibility, provide this property with additional information.\n   * https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-label\n   */\n  ariaLabel?: string;\n  /**\n   * Adds a specific shadow part attribute that can be selected with the CSS ::part pseudo-element.\n   * https://developer.mozilla.org/en-US/docs/Web/CSS/::part\n   */\n  part?: string;\n  /**\n   * Hide the suggestion if it's the last in the list.\n   */\n  hideIfLast?: boolean;\n}\n\n/**\n * List of suggestions that will be displayed along other lists (e.g recent queries) when the search box's input is selected.\n */\nexport interface SearchBoxSuggestions {\n  /**\n   * The search box will sort the position of suggestions using this value. The lowest value being first.\n   * By default, the DOM position will be used.\n   */\n  position: number;\n  /**\n   * Whether the suggestions should be listed in the right or left panel. By default, the suggestions are listed in the right panel.\n   */\n  panel?: 'left' | 'right';\n  /**\n   * Method that returns the list of elements which will be rendered in the list of suggestions.\n   */\n  renderItems(): SearchBoxSuggestionElement[];\n  /**\n   * Hook called when the user changes the search box's input value. This can lead to all the query suggestions being updated.\n   */\n  onInput?(): Promise<unknown> | void;\n  /**\n   * Hook called when the suggested query changes as a user traverses through the list of suggestions.\n   * This is used for instant results, which are rendered based on the current suggested query.\n   * @param q The new suggested query.\n   */\n  onSuggestedQueryChange?(q: string): Promise<unknown> | void;\n}\n\n/**\n * Event sent from the registered query suggestions to the parent search box.\n */\nexport type SearchBoxSuggestionsEvent<\n  SearchBoxController,\n  Bindings = AnyBindings,\n> = (\n  /**\n   * The bindings passed from the search box to the suggestions.\n   */\n  bindings: SearchBoxSuggestionsBindings<SearchBoxController, Bindings>\n) => SearchBoxSuggestions;\n\nconst searchBoxElements = [\n  'atomic-search-box',\n  'atomic-insight-search-box',\n  'atomic-commerce-search-box',\n] as const;\n\n/**\n * The bindings passed from the search box to the suggestions.\n */\nexport type SearchBoxSuggestionsBindings<\n  SearchBoxController,\n  Bindings = AnyBindings,\n> = Bindings & {\n  /**\n   * The unique id of the search box.\n   */\n  id: string;\n  /**\n   * Whether the search box is [standalone](https://docs.coveo.com/en/atomic/latest/usage/ssb/).\n   */\n  isStandalone: boolean;\n  /**\n   * The search box headless controller.\n   */\n  searchBoxController: SearchBoxController;\n  /**\n   * The number of queries to display when the user interacts with the search box.\n   */\n  numberOfQueries: number;\n  /**\n   * Whether to clear all active query filters when the end user submits a new query from the search box.\n   */\n  clearFilters: boolean;\n  /**\n   * Retrieves the suggested query, meaning the query that would be sent if the search is executed.\n   * The suggested query changes as a user traverses through the list of suggestions.\n   */\n  suggestedQuery(): string;\n  /**\n   * Removes the current suggestions.\n   */\n  clearSuggestions(): void;\n  /**\n   * Triggers update & retrieval of all suggestions.\n   */\n  triggerSuggestions(): void;\n  /**\n   * Retrieves the current suggestions.\n   */\n  getSuggestions(): SearchBoxSuggestions[];\n  /**\n   * Retrieves the current suggestions elements.\n   */\n  getSuggestionElements(): SearchBoxSuggestionElement[];\n};\n\nconst isLitElementLoosely = (candidate: unknown): candidate is LitElement =>\n  'updateComplete' in (candidate as LitElement) &&\n  (candidate as LitElement)['updateComplete'] instanceof Promise;\n\nconst dispatchSearchBoxSuggestionsEventEventually = async <\n  SearchBoxController,\n  Bindings = AnyBindings,\n>(\n  interfaceElement: Element,\n  element: HTMLElement,\n  event: SearchBoxSuggestionsEvent<SearchBoxController, Bindings>\n) => {\n  if (isLitElementLoosely(interfaceElement)) {\n    await interfaceElement.updateComplete;\n  } else if ('componentOnReady' in interfaceElement) {\n    await (interfaceElement as HTMLStencilElement).componentOnReady();\n  }\n  element.dispatchEvent(\n    buildCustomEvent('atomic/searchBoxSuggestion/register', event)\n  );\n};\n\n/**\n * Dispatches an event which retrieves the `SearchBoxSuggestionsBindings` on a configured parent search box.\n * @param event Event sent from the registered query suggestions to the parent search box.\n * @param element Element on which to dispatch the event, which must be the child of a configured search box.\n */\nexport const dispatchSearchBoxSuggestionsEvent = <\n  SearchBoxController,\n  Bindings = AnyBindings,\n>(\n  event: SearchBoxSuggestionsEvent<SearchBoxController, Bindings>,\n  element: HTMLElement,\n  allowedSearchBoxElements: readonly (typeof searchBoxElements)[number][] = searchBoxElements\n) => {\n  const interfaceElement = closest(element, searchBoxElements.join(', '));\n  if (!interfaceElement) {\n    throw new Error(\n      `The \"${element.nodeName.toLowerCase()}\" component was not handled, as it is not a child of the following elements: ${allowedSearchBoxElements.join(\n        ', '\n      )}`\n    );\n  }\n  dispatchSearchBoxSuggestionsEventEventually(interfaceElement, element, event);\n};\n\nexport function elementHasNoQuery(el: SearchBoxSuggestionElement) {\n  return !el.query;\n}\n\nexport function elementHasQuery(el: SearchBoxSuggestionElement) {\n  return !!el.query;\n}\n"],"version":3}